Building a symbol table

Symbol Table Specs:
Store as an object with different attributes ie. a = { 'PP':, 'cur_offset':, 'cur_scope': }

Symbol Table Entry Spec:
Lexeme of variables and functions ---------- Done
Types of variables and functions
sizes of variables
offsets of variables ---------- Done

Construction of LST AND GST:
GST to be defined __init__ function ---------- Done
CST to be defined __init__ function ---------- Done
Updates in current symbol table:
    On lbrace: 
        1) push scope done by lexer ---------- Done
        2) create new symbol table and link it with CST ---------- Done
        3) make the new symbol table as CST ---------- Done

    On rbrace:
        1) pop scope done by lexer ---------- Done
        2) if empty:
            delete the current symbol table ---------- Done
            remove the entry from the parent ---------- Done
        3) make the parent of CST as CST  ---------- Done

    Function_definition:
        1) create new symbol table and link it to parent and set it as CST

    Doubt: How to handle L attributed grammar in bottom up parsing

Functionalites of symbol table:
    addentry:
    removeetry:
    lookupentry:

Scope Handling
    To be done with symbol table
    Handling each function call as a new symbol table and new scope
    Handling each { '''some code''' } as a new scope and symbol table

/**********************************************************************************************/
Code for type checking
    Wrting the code of type checking
/**********************************************************************************************/

AST Construction

Operator Disambiguation:
    Use attributes
    Set priority order among the different types( ie char int float double )
    Check the type of each child, and assign type of operator to be the highest of the children

Typecasting to be done in 
    Expressions
        If the type of any child does not match with the operator type then add a type cast node (operator type) to the child -- Done
    Function Arguments
        Keep the input arg list, and check the type of each argument with list -- Done
    Return Values
    Think of more

Errors Handling
    Make of all possible error
    Assign type error in code
    handle the type of error while printing

    Context free errors:
        Keep the count variable for function calls and arrays
    Think of other possible ways


Handling Array of arrays in function calls
	we need to make sure that n-1 dimensions of a n dimension array object are constants

Recursion and Typechecking in Recursion:
	Break the function definition into 2 parts, first part consists of specifier and declarator andsecond part has compound statement the first part on completion adds the type specifier and the declator in the function table. In case of recursion, the declarator of the function is in the symbol table so it is not a problem. For checking return type, we check the last return specifier type of the last function pushed in the function table. -- Done	

TypeChecking in assignment expression 
	return a type for each expression and store it with the assignment expression

Checking the possibility of TypeCasting
	During the function call casting we have to check whether we can type cast the given argument to the required type or not
